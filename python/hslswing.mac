# ----------------------------------------------------------------
# HSL Swing
# 3 circular-swinging wanderers with changing colors
# ----------------------------------------------------------------

# version zero of the Apollo language
# the apollo language is a reverse-polish-notation architecture
%version 0
# standard device and common use numeric value symbols

%include symbols

# script to color-sequence the palette with a changing start angle
%include hsl-sequencer

# run this script's main app when done programming
%run-macro hslswing-app

#
# set constants for use in the script
# there are no variables; all constants are immutable
# these can be overridden on the command line, such as
#   valuename=someothervalue

# compute half of the device's total LEDs
# this value based on the current device allows for 
# scaling to run on any device
# recall the value for NUM-LEDS, which is automatically set per device
# the contents between the back-ticks is a Python expression
#   that will be evalated once any unresolved values are resolved
$max-width-half `<NUM-LEDS> / 2`

# cycle each swinger to the next state every 100 ticks
$cycle-time 100

# render the display buffer to the LEDs every 100 ticks
$render-time 100

# start a macro called `hslswing-app` and pre-assign in macro position #4
# pre-assigning macro numbers assures they can be easily restarted later
[hslswing-app 4]

        # mark this macro as an 'application'
	# this resets several device parameters, stops all running schedules
        #   and clears the display
	application

	# set the draw mode to overwrite (replace color)
	<DRAW-WRITE>
	draw-mode

	# schedule the render macro to run periodically
	(render <render-time>)

	# do the remainder of initializations
	# this is split off into its own macro rather than being included
	# with this one due to memory constraints and carry-over macros
	#
	# * there are 1024 bytes of macro memory
	# * each macro has storage for 15 bytes
	# * this leave room for 68 full-sized macros and a final 69th partial macro
	# * macros longer than 15 bytes extended into the adjacement macros, causing 
	#   them to be marked as 'used'
	#
	# when macros grow very large, they make it difficult for the packer to
	# fit the script into the available macros; also the device has maximum
	# command buffer size
	(init)

# start a macro called 'init'
# this will handle remaining setups
# a macro number will be assigned automatically for it
[init]

	# invoke a meta-template to start up the circular swingers
	# this creates two template-invocations, 
        # passing the string-replacement values "0" and "1"
	(((circular-swingers 2)))

	# start up the averaging swinger
	(average-swinger)

	# start up the hsl sequencer
	(hsl-sequencer-start)

# start a macro called 'render'
# this will push the display buffer to the LEDs periodically
# the special pre-assigned macro number "!" tells the compiler
#   to put this macro in the very last macro position
# rendering macros are typically small, so they're ideal to
#   use for this otherwise unusable space
# with 15-byte macros, the final macro has 4 bytes
# a command requires a single byte so up to four commands 
#   can be stored
[render !]

	# duplicate the first half of the LED colors to the second half, reversed
	mirror

	# push the display buffer to the LEDs
	flush

# create a template called 'circular-swingers' with 
#   a string-replacement placeholder of "X"
# this will create a copy of the template with
#   the incoming value replacing and "X" found in 
#   in the template (case-insensitively)
# this is used above to create several macro invocations
[[circular-swingers X
	(start-X)
]]

# invoke a template called 'circular-swinger' twice
#   passing in the values "0" and "1" to replace
#   the "X" in the duplicated tempates
# also pass in values for the color and type of 
#   circular sequencer to use
# the unresolved RED and GREEN values are defined
#   in symbols.mac, and resolve to their standard
#   palette positions (zero and three)
((circular-swinger 0 <RED> sws))
((circular-swinger 1 <GREEN> swc))

# define a template called 'circular-swinger' with 
#   three replacable values: 
#   (case-insensitive)
# when the template is invoked, the passed values
#   will be replaced in the duplicated script
[[circular-swinger X COLOR TYPE

	# create a templated macro called start-PASSED-VALUE
	# when the template is invoked, the passed value will
	#   be replaced with the first incoming value
	#   creating a unique macro name
	[start-X]

		# allocate a number sequencer named sequencer-PASSED-VALUE
		# when the template is invoked, the passed value will
		#   be replaced with the first incoming value
		#   naming a unique number sequencer
		# the newly-allocated sequencer number is combined
		#   with a second argument, and they're used below to 
		#   actually create the sequencer
		# the second argument specifies that the number sequencer
		#   will go up to (but excluding) one half of the number
		#   of device LEDs (for instance, 90 LEDs would be 0-44)
		{sequencer-X},<max-width-half>

		# create a sequencer of the passed-in type
		# using the above argument to set it up
	        TYPE

		# schedule a templated "drawing macro" called 
		#   render-PASSED-VALUE used to draw the swinger periodically
	        (render-X <cycle-time>)

	# create a templated macro called 'render-PASSED-VALUE'
	# this will be called periodically to advance this swinger
	#   to its next state, and draw it to the dispal buffer
	[render-X]

		# recall the sequencer number allocated above
		# to use an as argument for the following command
		<sequencer-X>

		# advance this sequencer to its next state
		# use "window-tracking" to specify a multiple
		#   pixel region that can be filled with a color
		#   to draw the animating swinger without gaps
		# it leaves two arguments on the stack:
		#   * offset
		#   * window
		# these define the starting and ending pixels
		#   to fill (min,max)
		sequence-next-window

		# set the offset and window according to the stack arguments
		position

		# recall the second passed argument to use an an argument
		# to the palette color command
		COLOR

		# insert a pixel, colored from the palette at the specified 
		#   position
		# the pixel is inserted at the current offset position
		palette-color

		# apply a fast-fade effect to the pixel
		# the fast-fade effect does a quick fade using
		#   bit-shifting for division
		fast-fade

		# fill the entire region with the color and effect at
		#   the insertion position (offset)
		flood

		# the offset and window must be reset to the default
		#   at the end of the macro if they were changed
		# if not reset, whatever operations occur next
		#   may happen within an unexpected region
		reset

# close the template definition
]]

#
# in addition to the two circular swingers above, 
# a third swinger averages the the two values
#

# create a macro to set up the averaging swinger
[average-swinger]

	# allowcate a number sequencer name
	#   and pass the total number of LEDs
	#   as a sequencer maximum
	# in this case, it is a macro-computed sequence
	#   not a simple number sequence, so the
	#   current integer value of the sequencer
	#   isn't used, but it's good practice to
	#   specify the maximum value, so it can be
	#   used to prevent out-of-range values 
	{sequencer-a},<NUM-LEDS>

	# specify a "wheel sequencer" using the above arguments
	# a wheel sequencer can be thought of as the numnber
	#   sequence being wrapped around a circle, starting
	#   over again when it reached the ends
	# for example, a max value of 4 would yield the sequence
	#   0 1 2 3 0 1 2 3 ...
        wheel-sequencer

	# schedule the swinger to periodically advance and draw
        (render-a <cycle-time>)

# create a macro to advance and draw the swinger
[render-a]
	# recall the allocated sequencer number
	#   and pass it, along with a sequencing option
	#   specifying to use a macro to compute the next
	#   position, and along with the macro number to call
	<sequencer-a>,<MACRO-SEQ>,<math-a>

	# get the next offset and position for continguous draw
	sequence-next-window

	# set the region for contigious draw filling
	position

	# specify the blue standard palette position (4)
	#   as an argument to the following palette color command
	<BLUE>

	# insert a pixel colored from the palette at the specified 
	#   position, at the current offset
	palette-color

	# apply a fast fade to the pixel
	fast-fade

	# fill the entire contiguous draw region
	flood

	# reset the offset and window
	reset

# create a macro to compute the position of the averaging swinger
[math-a]
	# recall the sequence number for the first circular sequencer
	#   and pass it along with a sequencer option to get the current
	#   computed value from that sequencer
	<sequencer-0>,<GET-COMPUTED>

	# get the sequencer value
	sequence

	# push it on the accumulator stack
	push

	# also get the current value of the second circular sequencer
	<sequencer-1>,<GET-COMPUTED>
	sequence

	# push its value on the accumulator stack
	push

	#
	# at this point, the first pushed value is in accumulator #1
	#   and the second pushed value in accumulator #0

	# compute the average of the two most recent stack values
	#   leaving the result on the accumulator stack and as 
	#   a command argument
	# the fact that it's a command argument will be used in the calling
	#   macro's sequencer to get the computed value
	average

